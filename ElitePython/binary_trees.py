"""Create and operate on Binary Trees"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Data Structures/Binary Trees/binary_trees.ipynb.

# %% auto 0
__all__ = ['visualize_tree', 'Node', 'set_parents', 'create_n_nodes', 'dfs_inorder', 'dfs_preorder', 'dfs_postorder', 'bfs',
           'insert_node', 'search_tree', 'delete_node']

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 3
from collections import deque
import matplotlib.pyplot as plt
import networkx as nx
from typing import Callable, Generator

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 5
def visualize_tree(root):
    if not root:
        print("Empty tree")
        return
    
    G = nx.DiGraph()
    pos = {}
    labels = {}
    node_id = 0
    
    def add_nodes(node, x=0.0, y=0.0, layer=1):
        nonlocal node_id
        if node:
            current_id = node_id
            node_id += 1
            G.add_node(current_id)
            pos[current_id] = (x, y)
            labels[current_id] = str(node.value)
            
            if node.left:
                left_id = node_id
                G.add_edge(current_id, left_id)
                add_nodes(node.left, x - 1/layer, y - 1, layer + 1)
            if node.right:
                right_id = node_id
                G.add_edge(current_id, right_id)
                add_nodes(node.right, x + 1/layer, y - 1, layer + 1)
            
            return current_id
    
    add_nodes(root)
    
    plt.figure(figsize=(3, 2))
    nx.draw(G, pos, labels=labels, with_labels=True, node_color='lightblue', 
            node_size=1000, font_size=16, font_weight='bold', arrows=True)
    plt.title("Binary Tree Visualization")
    plt.show()

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 14
class Node:
    """A node in a binary tree."""
    def __init__(self, key, left: "Node|None"=None, right: "Node|None"=None, parent: "Node|None" = None):
        self.value = key
        self.parent: Node|None = parent
        self.left: Node|None = left
        self.right: Node|None = right
    
    def __str__(self) -> str:
        """A string representation of the node including its value, left, and right children."""
        left_value = f"Node({self.left.value})" if self.left else None
        right_value = f"Node({self.right.value})" if self.right else None
        parent_value = f"Node({self.parent.value})" if self.parent else None
        return f"Node({self.value}, left={left_value}, right={right_value}, parent={parent_value})"

    def __repr__(self) -> str:
        """A representation of the node including its value, left, and right children."""
        return self.__str__()

    @property
    def height(self) -> int:
        return 1 + max(
            (self.left.height if self.left else 0), (self.right.height if self.right else 0)
        )
    
    @property
    def depth(self) -> int:
        return 1 + (self.parent.depth if self.parent else 0)


# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 15
def set_parents(node: Node, parent: Node|None=None) -> Node:
    """Set parent nodes given a root node."""
    if parent:
        node.parent = parent
    if node.left:
        set_parents(node.left, node)
    if node.right:
        set_parents(node.right, node)
    return node

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 21
def create_n_nodes(num=5) -> Node:
    assert num > 0
    nodes = [Node(i) for i in range(num)]
    for i in range(num):
        left_index = 2 * i + 1
        right_index = 2 * i + 2
        if left_index < num:
            nodes[i].left = nodes[left_index]
            nodes[left_index].parent = nodes[i]
        if right_index < num:
            nodes[i].right = nodes[right_index]
            nodes[right_index].parent = nodes[i]
    return nodes[0]  # root node

visualize_tree(create_n_nodes(1))
visualize_tree(create_n_nodes(5))
visualize_tree(create_n_nodes(9))

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 24
def dfs_inorder(node: Node) -> Generator[Node, None, None]:
    """Depth-first search.
    
    Visits left subtree, then node, then right subtree
    """
    if node.left:
        yield from dfs_inorder(node.left)
    yield node
    if node.right:
        yield from dfs_inorder(node.right)

list(dfs_inorder(root))

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 25
def dfs_preorder(node: Node) -> Generator[Node, None, None]:
    """Depth-first search.

    Visits the node, then left subtree, then right subtree.
    """
    yield node
    if node.left:
        yield from dfs_preorder(node.left)
    if node.right:
        yield from dfs_preorder(node.right)
list(dfs_preorder(root))

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 26
def dfs_postorder(node: Node) -> Generator[Node, None, None]:
    """Depth-first search.

    Visits the left subtree, then right subtree, then the node
    """
    if node.left:
        yield from dfs_postorder(node.left)
    if node.right:
        yield from dfs_postorder(node.right)
    yield node
list(dfs_postorder(root))

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 28
def bfs(node: Node) -> Generator[Node, None, None]:
    """Breadth-first search."""
    queue = deque([node])
    while queue:
        node = queue.popleft()
        yield node
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
list(bfs(root))

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 30
def insert_node(root: Node, key):
    """"""
    queue = deque([root])
    while queue:
        node = queue.popleft()
        if node.left:
            queue.append(node.left)
        else:
            node.left = Node(key=key, left=None, right=None, parent=node)
            break

        if node.right:
            queue.append(node.right)
        else:
            node.right = Node(key=key, left=None, right=None, parent=node)
            break
    

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 33
def search_tree(root: Node, key, traversal_func: Callable[[Node], Generator[Node, None, None]]) -> Node|None:
    for node in traversal_func(root):
        if node.value == key:
            return node
    else:
        return None

# %% ../nbs/Data Structures/Binary Trees/binary_trees.ipynb 36
def delete_node(root: Node, key=None) -> Node|None:
    """Uses BFS to delete the node with a key and swap it with the right-most node."""

    # if root has no children
    if root.left or root.right:
        pass
    else:
        del root
        return None

    # find the deepest root node and its parent
    queue: deque[tuple[Node, Node|None]] = deque([(root, None)])  # root has no parent
    last_parent = None
    last_node = None
    while queue:
        last_node, last_parent = queue.popleft()
        if last_node.left:
            queue.append((last_node.left, last_node))
        if last_node.right:
            queue.append((last_node.right, last_node))

    # delete the leaf node
    if last_parent:
        if last_parent.right:
            last_parent.right = None
        elif last_parent.left:
            last_parent.left = None
    else:
        raise NotImplementedError("Parent of right-most node not found.")
    
    # find the node with value == key
    if last_node and root.value == key:
        last_node.left = root.left
        last_node.right = root.right
        del root
        return last_node
    elif last_node:
        pass
    else:
        raise NotImplementedError

    target_queue: deque[Node] = deque([root])
    while target_queue:
        node = target_queue.popleft()
        if node.left:
            if node.left is last_node:
                node.left = None
                return root
            elif node.left.value == key:
                node.left = last_node
                last_node.parent = node
                return root
            target_queue.append(node.left)
        if node.right:
            if node.right is last_node:
                node.right = None
                return root
            elif node.right.value == key:
                node.right = last_node
                last_node.parent = node
                return root
            target_queue.append(node.right)
    return root
